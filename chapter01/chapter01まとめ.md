# Chapter1 : Layering
階層化(Layering)は複雑なシステムを分解するために使用する一般的な手法。

階層化されたシステムでは、各レイヤーが下のレイヤーの上に乗っている。各レイヤーは下のレイヤーを意識するが、下のレイヤーに隠されたさらに下のレイヤーへは意識しない。

+ 階層化の利点
  + 他レイヤーを知らないくても、ある1つのレイヤーを首尾一貫した(まとまりのある)全体として私たちは理解することができる。
    + イーサネットの仕組みの詳細を知らなくても、TCP の上に FTP サービスを構築する方法を理解することができる。
  + 基本的に同じサービスの代替実装によってレイヤーを置き換えることができる。
    + FTP サービスは、イーサネット、PPP、またはケーブル会社が使用しているものを変更せずに実行することができる。
  + レイヤー間の依存関係を最小限にできる。
    + ケーブル会社が物理的な伝送システムを変更してもIPが動けばFTPは動く。
  
  + レイヤーは標準化するのに適している。
    + TCP and IP are standards because they define how their layers should operate
  
  + 一度レイヤーを構築すれば、多くの高レベルなサービスを使用することができる。
    + 例えば、TCP/IP は FTP、telnet、SSH、HTTP で使われています。そうでなければ、これらの高レベルのプロトコルはすべて独自の低レベルのプロトコルを書かなければなりません。 

+ 階層化の欠点
  + レイヤーはすべてのものをうまくカプセル化できるものではない。その結果、カスケード的な(連鎖的な)変更が発生する可能性がある。
    + レイヤリングされたエンタープライズアプリケーションでの典型的な例は、UIに表示する必要のあるフィールドを追加することですが、それはデータベースになければならず、その間のすべてのレイヤーに追加しなければなりません。
  + 余分なレイヤーはパフォーマンスに悪影響を与える可能性がある。
    + 各レイヤーでは、通常、ある表現から別の表現に変換する必要があります。しかし、基礎となる機能をカプセル化することで、それを補う以上の効率的な利益が得られることがよくあります。トランザクションを制御するレイヤーは最適化され、すべてが高速化されます。

**階層化されたアーキテクチャの最も難しい部分は、どのレイヤを持つべきか、各レイヤの責任は何であるべきかを決めること**


## The Evolution of Layers in Enterprise Applications(エンタープライズアプリケーションにおけるレイヤーの発展について)
**レイヤの概念は90年代のクライアント/サーバシステムの台頭で明確になる**

  + 2層のシステム
  + サーバは通常リレーショナルデータベース
  + クライアントはユーザインターフェースと他のアプリケーションコードを保持
  + クライアントツールでは、SQLを意識したUIウィジェットを保持し、ドロップ＆ペーストでデータベースに接続でき、それにより画面を構築

+ リレーショナルデータの表示と単純な更新だけであれば、2層のシステムは非常にうまく機能していた。

**問題はビジネスルール、検証、計算などのドメインロジックにあった**

+ 通常、ロジックはクライアント側で記述している。(UI画面に直接ロジックを埋め込む)
  + ドメインロジックが複雑になることで、コードの扱いが困難に。
  + ロジックを画面に埋め込むとコードの複製が容易で多発。結果、類似したコードを探す羽目に。 
+ ドメインロジックをストアドプロシージャとしてデータベースに格納する方法もあった。
  + ストアドプロシージャでは構造化の仕組みが限定されており、また厄介なコードになった。


**ドメインロジックの解決策を持っていたオブジェクト指向が台頭してきた。**

+ 3層システムへの移行はいろいろなメリットがあった
  + 複雑なドメインロジックをすべてUIの外に移動させ、オブジェクトを使って適切に構造化できるレイヤーに配置することができる
  + 多くのシステムがシンプルで、問題が単純な場合、そのような場合にはクライアント・サーバが採用された。
+ 筆者曰く、ウェブの台頭により流行りだした。
  + ブラウザを使用してクライアント/サーバアプリケーションをデプロイしたいと考えた
  + すべてのビジネスロジックがリッチクライアントに埋もれていた場合、すべてのビジネスロジックは、Webインタフェースを持つようにやり直す必要があった。
  + うまく設計された3層構造は新たにプレゼンテーションレイヤーを追加するだけでよい。




## The Three Prinspal Layers

**プレゼンテーション、ドメイン、データソースという3つの主要なレイヤーのアーキテクチャを中心に議論**

### プレゼンテーションロジックについて
+ プレゼンテーションロジックとは、ユーザーとソフトウェア間のインタラクションをどのように処理するか
+ プレゼンテーション層の主な役割について
  + ユーザーに情報を表示すること
  + ユーザーからのコマンドを解釈してドメインとデータソースのアクションに変換すること

### データソースロジックについて
+ データソースロジックはアプリケーションに代わってタスクを実行する他のシステムと通信します。
  + これらのシステムには、トランザクション モニター、他のアプリケーション、メッセージング システムなど

### プレゼンテーションとデータソースの区別
+ プレゼンテーションは、自分のシステムが誰かに提供するサービスのための外部インターフェース
+ データソースは、自分にサービスを提供しているものへのインターフェース


**全てのエンタープライズアプリケーションで、プレゼンテーション、ドメイン、データソースの3つの共通の責務(層)をどのように分離するかは、アプリケーションの複雑さに依存する**

### 依存関係のルール

1. **ドメインとデータソースは決してプレゼンテーションに依存してはいけない(プレゼンテーションのサブルーチン呼び出しはダメ)**
これによるメリット
 + 同じ基盤の上で異なるプレゼンテーションを代用することが容易
 + より深いところで深刻な影響を受けることない
 + プレゼンテーションを修正することが容易

2. **ドメインとデータソースの関係はデータソースに使用されるアーキテクチャパターンに依存**


### ドメインロジックの扱い

ドメインロジックを扱う上で最も難しいことは、

+ ドメインロジックが何であるか
+ 他のロジック形式が何であるか

を認識すること。

+ 筆者自身で確認している方法
  + ウェブアプリケーションにコマンドラインインタフェースなど、根本的に異なるレイヤをアプリケーションに追加することを想像すること
  + そのために複製しなければならない機能があれば、それはドメインロジックがプレゼンテーションに漏れていることを示している

## Choosing Where to Run Yours Layers

### ほとんどの業務アプリの処理はクライアントか、デスクトップか、サーバ上で実行される

+ 多くの場合、シンプルなケースとしてサーバ上で全て実行される
  + 実行場所が限定されており、拡張や修正がしやすい
  + デスクトップにデプロイして、サーバと同期させることを気にしなくてすむ
  + 他のソフトウェアの互換性を気にしなくてすむ

+ クライアント上で実行することを支持する話は、`responsiveness`または`disconnected operation`に関係している
  + サーバ上でロジックが実行されると、通信の往復(ラウンドトリップ)が発生
    + 迅速な応答が必要な場合には、ラウンドトリップが邪魔
    + ネットワーク接続も必要
    + 切断時の操作については本書では触れない


### プレゼンテーション層を実行する場所は開発者が望むユーザーインターフェースの種類に依存

+ リッチクライアントを実行する＝クライアント上でプレゼンテーションを実行する
+ Webインターフェースを実行する＝サーバ上で実行

### ドメインロジックはどこで行うのか

+ ドメインロジックはサーバ上だけでもクライアント上だけでも実行可能かつ分割して実行可能
+ メンテナンスを容易にするためにはすべてサーバ上に実行することがベスト
  + クライアントに移動が必要になるかは**responsiveness**か**disconnected operation**のどちらか

+ すべてのドメインロジックをクライアント上で実行する問題点はアップグレードとメンテナンス


+ デスクトップとサーバの両方に分割していると、ドメインロジックがどこで行われているかわからず、最悪に思える、、
  + これを行う理由は、クライアント上で実装されているドメインロジックが少量であるから

**これを解決するには、システム内のあらゆる部分に依存しない自己完結のモジュール内にロジックの部分を分離すること**
(The trick then is to isolate this piece of logic in a self-contained module that isn’t dependent on any other part of the system. )
  + サーバ上でもクライアントでも作動する

### 処理ノードを一度選択すると、単一のプロセス内で全てのコードを保持する必要がある。
**絶対に必要な場合を除いて、レイヤを別々のプロセスに分離してはいけない**

* 複雑性のブースター(complexity boosters)について
