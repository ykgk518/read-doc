レイヤー化は、ソフトウェア設計者が複雑なソフトウェアシステムを分解するために使用する最も一般的なテクニックの一つです。マシンアーキテクチャでは、オペレーティングシステムの呼び出しを伴うプログラミング言語から、デバイスドライバやCPU命令セット、チップ内のロジックゲートへと階層化されています。ネットワークは、TCPの上にFTPがあり、IPの上にイーサネットの上にFTPがあります。

システムをレイヤーで考えるとき、ソフトウェアの主要なサブシステムがレイヤーケーキのような形で配置され、各レイヤーが下のレイヤーの上に乗っていることを想像します。
このスキームでは、上位レイヤは下位レイヤによって定義された様々なサービスを使用しますが、下位レイヤは上位レイヤを意識していません。
さらに、各レイヤーは通常、その下のレイヤーを上のレイヤーから隠しているので、レイヤー4はレイヤー2のサービスを利用するレイヤー3のサービスを利用しますが、レイヤー4はレイヤー2を意識していません。 (すべてのレイヤリングアーキテクチャがこのように不透明であるわけではありませんが、ほとんどのアーキテクチャは、いや、むしろほとんどが不透明です)。

システムをレイヤーに分解することには、いくつかの重要な利点があります。

 - 他のレイヤーについてあまり知らなくても、単一のレイヤーを首尾一貫した全体として理解することができます。イーサネットの仕組みの詳細を知らなくても、TCP の上に FTP サービスを構築する方法を理解することができます。

 - 同じ基本的なサービスの代替実装でレイヤーを置き換えることができます。FTP サービスは、イーサネット、PPP、またはケーブル会社が使用しているものを変更せずに実行することができます。

- レイヤ間の依存関係を最小限に抑えることができます。ケーブル会社が物理的な伝送システムを変更しても、IP が動作するようにすれば、FTP サービスを変更する必要はありません。

 - レイヤーは標準化のための良い場所になります。TCP と IP は、それらのレイヤがどのように動作するかを定義しているため、標準化されています。

- 一度レイヤを構築してしまえば、それを多くの高レベルのサービスに使用することができます。例えば、TCP/IP は FTP、telnet、SSH、HTTP で使われています。そうでなければ、これらの高レベルのプロトコルはすべて独自の低レベルのプロトコルを書かなければなりません。

レイヤー化は重要な技術ですが、欠点もあります。
 - レイヤーはいくつかのものをカプセル化していますが、すべてのものをうまくカプセル化しているわけではありません。その結果、カスケード的な変更が発生することがあります。レイヤリングされたエンタープライズアプリケーションでの典型的な例は、UIに表示する必要のあるフィールドを追加することですが、それはデータベースになければならず、その間のすべてのレイヤーに追加しなければなりません。
- 余分なレイヤーはパフォーマンスに悪影響を与える可能性があります。各レイヤーでは、通常、ある表現から別の表現に変換する必要があります。しかし、基礎となる機能をカプセル化することで、それを補う以上の効率的な利益が得られることがよくあります。トランザクションを制御するレイヤーは最適化され、すべてが高速化されます。

しかし、レイヤ化されたアーキテクチャの最も難しい部分は、どのレイヤを持つべきか、各レイヤの責任は何であるべきかを決めることです。


エンタープライズアプリケーションにおけるレイヤーの進化 

私は若すぎてバッチシステムの初期の頃の仕事をしたことがありませんが、当時の人々はレイヤーについてあまり考えていなかったような気がします。
あなたは、ファイル（ISAM、VSAMなど）のいくつかのフォームを操作するプログラムを書いて、それがあなたのアプリケーションでした。レイヤーを適用する必要はありません。
レイヤの概念は、90年代のクライアント・サーバ・システムの台頭でより明確になりました。これらは2層のシステムでした。クラアントはユーザインタフェースと他のアプリケーションコードを保持し、サーバは通常リレーショナルデータベースでした。一般的クライアントツールはVB、Powerbuilder、Delphiでした。これらのツールは、SQLを意識したUIウィジェットを持っていたため、デタを多用するアプリケーションの構築を特に容易にしました。したがって、コントロールをデザイン領域にドラッグし、プロパティートを使ってコントロールをデータベースに接続することで画面を構築することができました。 アプリケーションがリレーショナル・データの表示と単純な更新だけであれば、これらのクライアント・サーバ・システムは非常にまく機能します。問題は、ビジネスルール、検証、計算などのドメインロジックにあります。通常、これらのロジックはクライアン側で記述しますが、これは厄介で、通常はUI画面に直接ロジックを埋め込むことで行われていました。ドメインロジックが複雑になにつれ、このコードを扱うのは非常に難しくなりました。
さらに、ロジックを画面に埋め込むとコードの複製が容易になるため、簡単な変更でも多くの画面で類似したコードを探すことになってしまいます。

別の方法としては、ドメインロジックをストアドプロシージャとしてデータベースに格納する方法がありました。しかし、ストアドプロシージャでは構造化のメカニズムが限られており、これがまた厄介なコードにつながっていました。また、多くの人がリレーショナル・データベースを好んだのは、SQLがデータベース・ベンダーを変更できる標準だったからです。実際にこのようなことをする人はほとんどいませんでしたが、多くの人は移植コストをかけずにベンダーを変更できるオプションが好きでした。データベースはすべてプロプライエタリであるため、ストアドプロシージャはそのオプションを削除しました。

クライアント・サーバーが人気を博したのと同時に、オブジェクト指向の世界も台頭してきました。
オブジェクトコミュニティは、ドメインロジックの問題に対する答えを持っていました。それは、3層システムへの移行です。このアプローチでは、UIのためのプレゼンテーション層、ドメインロジックのためのドメイン層、そしてデータソースがあります。この方法では、複雑なドメインロジックをすべてUIの外に移動させ、オブジェクトを使って適切に構造化できるレイヤーに配置することができます。

にもかかわらず、オブジェクトの流行はほとんど進みませんでした。実際のところ、多くのシステムはシンプルであったか、少なくともそのように始まっていたのです。3層構造のアプローチには多くの利点がありましたが、問題が単純な場合には、クライアント・サーバ用のツールは説得力がありました。クライアント・サーバのツールもまた、3層構成では使いづらい、あるいは使いこなせないものでした。

ここでの衝撃は、ウェブの台頭だと思います。突然、人々はWebブラウザを使ってクライアント・サーバ・アプリケーションを展開したいと思うようになりました。しかし、すべてのビジネスロジックがリッチクライアントに埋もれていた場合、すべてのビジネスロジックは、Webインタフェースを持つようにやり直す必要がありました。うまく設計された3層構造のシステムは、新しいプレゼンテーション層を追加するだけで終わりました。
さらに、Javaでは、恥ずかしげもなくオブジェクト指向の言語が主流になりました。Webページを構築するために登場したツールは、SQLに縛られていなかったため、第3のレイヤーを利用しやすくなっていました。

人々がレイヤリングについて議論するとき、しばしばレイヤーとティアという用語について混乱が生じます。しばしばこの2つは同義語として使われますが、ほとんどの人は階層を物理的な分離を意味するものとして捉えています。
クライアントとサーバのシステムは、しばしば 2 層のシステムと表現されますが、その分離は物理的なものです。レイヤーを使用しているのは、異なるマシン上でレイヤーを実行する必要がないことを強調するためです。ドメインロジックの明確なレイヤーは、デスクトップかデータベースサーバーのどちらかで実行されることがよくあります。この状況では、2つのノードがありますが、3つの異なるレイヤーがあります。ローカルデータベースを使えば、1台のラップトップで3つのレイヤーをすべて実行することができますが、3つの異なるレイヤーが存在することになります。


三つの主な層

 この本では、プレゼンテーション、ドメイン、データソースという3つの主要なレイヤーのアーキテクチャを中心に議論しています。(Brown et al.]で使われている名前に従っています)。表1.1はこれらのレイヤーをまとめたものです。表1.1. 3つの主要なレイヤー 

プレゼンテーション ロジックとは、ユーザーとソフトウェア間のインタラクションをどのように処理するかということです。これは、コマンドラインやテキストベースのメニューシステムのようにシンプルなものもありますが、最近ではリッチクライアントのグラフィック UI や HTML ベースのブラウザ UI が主流です。(この本ではリッチクライアントとは、HTML ブラウザではなく、Windows/Swing/ファットクライアント UI を意味しています)。プレゼンテーション層の主な役割は、ユーザーに情報を表示することと、ユーザーからのコマンドを解釈してドメインとデータソースのアクションに変換することです。

データソースロジックは、アプリケーションに代わってタスクを実行する他のシステムと通信します。これらのシステムには、トランザクション モニター、他のアプリケーション、メッセージング システムなどがあります。
ほとんどのエンタープライズ アプリケーションでは、データ ソース ロジックの最大の部分は、主に永続的なデータの保存を担当するデータベースです。
残りの部分は、ビジネスロジックとも呼ばれるドメインロジックです。これは、アプリケーションが作業しているドメインのために必要な作業です。これには、入力と保存されたデータに基づく計算、プレゼンテーションから入ってくるデータの検証、プレゼンテーションから受信したコマンドに応じて、どのようなデータ ソース ロジックをディスパッチするかを正確に把握することが含まれます。

時には、ドメイン レイヤーがプレゼンテーションからデータ ソースを完全に隠すようにレイヤーが配置されていることもあります。
しかし、多くの場合、プレゼンテーションはデータストアに直接アクセスします。これは純粋ではありませんが、実際にはより良く動作する傾向があります。プレゼンテーションはユーザーからのコマンドを解釈し、データソースを使用してデータベースから関連するデータを取り出し、ドメインロジックにそのデータを操作させてからグラスに表示することができます。
1つのアプリケーションは、しばしばこれら3つの主題領域のそれぞれの複数のパッケージを持つことができます。リッチクライアントインターフェースだけでなく、コマンドラインからも操作できるように設計されたアプリケーションは、リッチクライアントインターフェース用とコマンドライン用の2つのプレゼンテーションを持つことになります。

複数のデータソースコンポーネントは、異なるデータベースに対して存在するかもしれませんが、既存のパッケージとの通信のためには特に一般的です。ドメインであっても、お互いに比較的離れた別の領域に分割されているかもしれません。特定のデータソースパッケージは、特定のドメインパッケージでのみ使用されるかもしれません。ここまではユーザの話をしてきました。

これは当然、ソフトウェアを動かしている人間がいない場合はどうなるのかという疑問を投げかけることになります。これは、ウェブサービスのような新しくてファッショナブルなものかもしれませんし、バッチプロセスのようなありふれた便利なものかもしれません。後者の場合、ユーザーはクライアントプログラムです。この時点で、プレゼンテーション層とデータソース層の間には、外の世界との接続を目的とした多くの類似点があることが明らかになります。これはAlistair Cockburnの六角形アーキテクチャパターン[wiki]の背後にある論理であり、外部システムへのインターフェースに囲まれたコアとしてあらゆるシステムを視覚化します。
六角形アーキテクチャでは、外部のすべてのものは基本的に外部のインターフェイスであり、したがって、私の非対称的なレイヤリングスキームよりもむしろ対称的なビューです。
私は、あなたが他の人にサービスとして提供するインターフェイスと他の人のサービスのあなたの使用の間になされるべき良い区別があると思うので、私はこの非対称性が有用であることを見つけます。
核心に迫ると、これは私がプレゼンテーションとデータソースの間で行っている本当の区別です。プレゼンテーションとは、複雑な人間であれ、単純なリモート・プログラムであれ、あなたのシステムが他の誰かに提供するサービスのための外部インターフェイスです。
データソースは、あなたにサービスを提供しているものへのインターフェイスです。
クライアントの違いによってサービスに対する考え方が変わるので、これらを別の角度から考えることは有益だと思います。

すべてのエンタープライズアプリケーションで、プレゼンテーション、ドメイン、データソースの3つの共通の責任層を識別することができますが、それらをどのように分離するかは、アプリケーションの複雑さに依存します。データベースからデータを引っ張ってきてWebページに表示する単純なスクリプトは、すべて1つの手順になるかもしれません。それでも私は3つのレイヤーを分離するように努力しますが、その場合、各レイヤーの動作を別々のサブルーチンに配置することによってのみ、それを行うかもしれません。システムが複雑になるにつれて、私は3つのレイヤーを別々のクラスに分割します。複雑さが増すにつれて、私はクラスを別々のパッケージに分割します。私の一般的なアドバイスは、問題に最も適した分離の形を選択することですが、少なくともサブルーチンレベルでは何らかの分離を行うようにしてください。


分離と合わせて、依存関係についても地道なルールがあります。ドメインとデータソースは、決してプレゼンテーションに依存してはいけません。つまり、ドメインやデータソースコードからプレゼンテーションコードへのサブルーチン呼び出しはあってはならないということです。このルールにより、同じ基盤の上で異なるプレゼンテーションを代用することが容易になり、より深いところで深刻な影響を受けることなく、プレゼンテーションを修正することが容易になります。ドメインとデータソースの関係はより複雑で、データソースに使用されるアーキテクチャパターンに依存します。
　
ドメインロジックを扱う上で最も難しいのは、何がドメインロジックで何が他の形式のロジックなのかを認識するのが難しいことだと思われます。私が好きな非公式のテストは、ウェブアプリケーションにコマンドラインインタフェースなど、根本的に異なるレイヤをアプリケーションに追加することを想像することです。そのために複製しなければならない機能があれば、それはドメインロジックがプレゼンテーションに漏れていることを示しています。同様に、リレーショナル データベースを XML ファイルに置き換えるためにロジックを複製する必要がありますか？

 その良い例として、私が教えてもらったシステムでは、前月より10%以上売れた製品のリストがすべて赤色で表示されていました。これを行うために、開発者はプレゼンテーション・レイヤーに、今月の売上と先月の売上を比較し、その差が10パーセント以上であれば、色を赤に設定するロジックを配置しました。

問題は、これがプレゼンテーションにドメインロジックを入れていることです。レイヤーを適切に分離するためには、ドメイン・レイヤーの中に、製品の売上が向上しているかどうかを示すメソッドが必要です。このメソッドは2ヶ月間の比較を行い、ブール値を返します。プレゼンテーション層は、このブール値メソッドを呼び出し、真であれば、製品を赤くハイライトします。このようにプロセスは、ハイライトできるものがあるかどうかの判断と、ハイライトする方法の選択という2つの部分に分かれています。これについては、独断的になりすぎているのが気になります。アラン・ナイト氏は本書をレビューする際に、"それをUIに入れるだけで地獄への滑り台の第一歩なのか、それとも独断的な純粋主義者だけが反対するような完全に合理的なことをするのか "で悩んだとコメントしています。不安になるのはその両方だからです！」とコメントしています。



レイヤーの実行場所の選択


この本の大部分では、論理レイヤ、つまり、システムの異なる部分間の結合を減らすために、システムを別々の部分に分割することについてお話します。
レイヤ間の分離は、レイヤがすべて 1 台の物理マシン上で動作している場合でも有用です。しかし、システムの物理的な構造によって違いが出る場合もあります。

ほとんどのISアプリケーションでは、処理をクライアント上で実行するか、デスクトップマシン上で実行するか、サーバー上で実行するかを決定します。多くの場合、最も単純なケースは、すべてをサーバー上で実行することです。Webブラウザを使用するHTMLフロントエンドは、これを行うための良い方法です。サーバー上で実行することの大きな利点は、限られた場所にあるため、すべてのものをアップグレードしたり修正したりするのが簡単なことです。多くのデスクトップにデプロイして、それらをすべてサーバーと同期させておくことを心配する必要はありません。他のデスクトップソフトウェアとの互換性を心配する必要はありません。

クライアント上で実行することを支持する一般的な議論は、応答性や切断された操作に関係しています。サーバー上で実行されるロジックは、ユーザーが何かをしたときに反応するためにサーバーを往復する必要があります。ユーザーが何かをいじってすぐにフィードバックを見たい場合は、ラウンドトリップが邪魔になります。また、実行するためにはネットワーク接続も必要です。ネットワークはどこにでもありたいと思っているかもしれませんが、これをタイプしている時点では31,000フィートの高さにはありません。すぐにどこにでもあるかもしれませんが、デッドエンド・クリークにワイヤレスのカバレッジが届くのを待たずに、今すぐにでも仕事をしたい人がいます。接続されていない操作は特別な課題をもたらします、そして、私はそれをこの本の範囲外に置くことにしました。

これらの一般的な力が整っていれば、レイヤーごとにオプションを見ることができます。データソースはほとんど常にサーバー上でのみ実行されます。例外は、サーバーの機能をそれなりに強力なクライアントに複製する場合で、通常は切断された操作をしたい場合です。
 この場合、切断されたクライアント上のデータソースへの変更は、サーバーと同期させる必要があります。先に述べたように、これらの問題は別の日に、あるいは別の作者に任せることにしました。

プレゼンテーションをどこで実行するかの決定は、どのようなユーザーインターフェイスを使用するかに大きく依存します。
リッチクライアントを実行することは、クライアント上でプレゼンテーションを実行することを意味します。Webインターフェイスを実行するということは、ほとんどの場合、サーバー上で実行することを意味します。例外として、デスクトップ上で Web サーバーを実行しているクライアントソフトウェア（Unix の世界では X サーバーなど）のリモート操作などがありますが、これらの例外はまれです。B2Cシステムを構築しているのであれば、選択の余地はありません。どんなTom、Dick、Harrietでもサーバーに接続することができますが、TRS-80を使ってオンラインショッピングをしたいと主張する人がいるため、そのような人を追い払うことはできません。この場合、サーバーですべての処理を行い、ブラウザが処理できるように HTML を提供します。HTML オプションの限界は、意思決定のすべてのビットがクライアントからサーバーまでの往復を必要とすることで、応答性が損なわれることです。ブラウザ スクリプトやダウンロード可能なアプレットを使用することでラグをある程度軽減することができますが、ブラウザの互換性が低下し、他の頭痛の種を増やす傾向があります。純粋な HTML であればあるほど、生活は楽になります。

たとえすべてのデスクトップが IS 部門によって愛情を込めて手作りされたものであっても、このような楽な生活は魅力的です。クライアントを最新の状態に保ち、他のソフトウェアとの互換性エラーを回避することは、シンプルなリッチクライアントシステムでさえ抱える問題です。

人々がリッチクライアントのプレゼンテーションを望む第一の理由は、ユーザーが行うタスクが複雑であり、使い勝手の良いアプリケーションを持つためには、Web GUIが提供できる以上のものが必要になるからです。しかし、ますます人々はWebフロントエンドをより使いやすくする方法に慣れてきており、リッチクライアントプレゼンテーションの必要性を減らしています。これを書いている私は、できることならば Web プレゼンテーションを、どうしても必要ならばリッチクライアントを強く支持しています。

ここで、ドメインロジックの話になります。ビジネスロジックをすべてサーバー上で実行することも、すべてクライアント上で実行することもできますし、分割することもできます。繰り返しになりますが、メンテナンスを容易にするためには、すべてサーバー上で実行するのがベストな選択です。それをクライアントに移動させる必要があるのは、応答性か切断して使用するかのどちらかです。

クライアント上でロジックを実行する必要がある場合は、クライアント上ですべてのロジックを実行することを検討してみてください。通常、これはリッチクライアントと相性が良く、クライアントマシン上で Web サーバーを実行しても応答性はあまり良くありません。この場合でも、トランザクションスクリプト (110) またはドメインモデル (116) を使用して、ドメインロジックをプレゼンテーションとは別のモジュールに入れておくことができます。すべてのドメインロジックをクライアントに置く場合の問題点は、アップグレードやメンテナンスの手間が増えることです。

デスクトップとサーバーの両方に分割するのは、ロジックの一部がどこにあるかわからないので、両方の世界で最悪のことのように聞こえます。これを行う主な理由は、クライアント上で実行する必要のあるドメインロジックが少量しかないからです。次に、このロジックをシステムの他の部分に依存しない自己完結型のモジュールに分離するのがコツです。そうすれば、そのモジュールをクライアントでもサーバーでも実行することができます。このためには、多少の煩わしいジグザグな作業が必要になりますが、この作業を行うには良い方法です。

処理ノードを選択したら、あるノードのコードはすべて単一のプロセスで処理するようにしましょう。どうしても必要な場合を除き、レイヤーを個別のプロセスに分割しないようにしてください。リモート・ファサード(388)やデータ転送オブジェクト(401)のようなものを追加しなければならないため、パフォーマンスが低下し、複雑さが増すことになります。

これらの機能の多くは、Jens Coldewey 氏が「複雑さのブースター」と呼んでいるものであり、分散、明示的なマルチスレッド、パラダイム・チャズム（オブジェクト/リレーショナルなど）、マルチプラットフォーム開発、極端なパフォーマンス要件（毎秒 100 トランザクション以上など）があることを覚えておくことが重要です。これらはすべて高いコストを伴います。確かにそれをしなければならない時もありますが、開発と継続的なメンテナンスの両方に費用がかかることを決して忘れないでください。
