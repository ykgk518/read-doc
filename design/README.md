# 目次

- [目次](#目次)
- [素晴らしいソフトウェアを作り上げる](#素晴らしいソフトウェアを作り上げる)
- [ソフトウェアの基本構造](#ソフトウェアの基本構造)
- [品質特性とは](#品質特性とは)
  - [ISO 25010](#iso-25010)
    - [利用時の品質モデル](#利用時の品質モデル)
    - [製品品質モデル](#製品品質モデル)
- [設計のマインドセット](#設計のマインドセット)
- [要求エンジニアリング](#要求エンジニアリング)
  - [方向付け](#方向付け)
  - [要求獲得](#要求獲得)
- [設計](#設計)
- [モデルで複雑さを扱う](#モデルで複雑さを扱う)
- [パターンの土台を身につける](#パターンの土台を身につける)
- [データ設計](#データ設計)
- [インタフェース設計](#インタフェース設計)
  - [外部インタフェース](#外部インタフェース)
  - [内部インタフェース](#内部インタフェース)
- [設計判断を可視化する](#設計判断を可視化する)
- [潜在的な解決策を探る](#潜在的な解決策を探る)
- [比較評価マトリクス](#比較評価マトリクス)
- [アーキテクチャデシジョンレコード(ADR)](#アーキテクチャデシジョンレコードadr)
  - [記述](#記述)
  - [テンプレート](#テンプレート)
- [SOLID原則](#solid原則)
  - [SRP (Single Responsibility Principle)](#srp-single-responsibility-principle)
  - [OCP (Open Closed Principle)](#ocp-open-closed-principle)
  - [LSP (Liskov Substitution Principle)](#lsp-liskov-substitution-principle)
  - [ISP (Interface Segregation Principle)](#isp-interface-segregation-principle)
  - [DIP (Dependency Inversion Principle)](#dip-dependency-inversion-principle)
- [引用・参考](#引用参考)

# 素晴らしいソフトウェアを作り上げる
ソフトウェアシステムを構築する際に正しく行わなければならないことはたくさんある。

アーキテクチャはそれらを結びつけて、成功のための基盤を提供する。

アーキテクチャとは品質特性を満たすためにソフトウェアをどう構成するか、ということに対する設計判断の集合

アーキテクチャを設計することによって以下の恩恵が受けれる。

* 大きな問題をより小さく、より管理しやすい問題へと変える
* 協働の仕方を示す
  * ソフトウェア開発は技術であると同時に人間的なコミュニケーションであること
  * ソフトウェア開発を進める上で、どのように一緒に働くかを考えるのはかなり重要
* 複雑な問題について会話するための語彙を提供
  * アーキテクチャ(要素と構造と関係性)の考えや中核語彙を使うと良い
* 機能以外の物に目を向けれる
  * コストや制約、スケジュール、リスク、チーム、品質特性に目を向けれる
* 後に起きる大きな問題を発見することができる
* 変化への柔軟な対応を可能にする

# ソフトウェアの基本構造
ソフトウェアには構造があって、構造は**要素**と別の**要素**を**関係**を築く

例えば、要素はクラス、パッケージ、レイヤー、オブジェクト、プロセス、サーバなど
関係の例は「〜を使用する」、「〜に依存する」、「〜を呼び出す」、「〜の上で実行する」 など

# 品質特性とは
品質特性とは?
ソフトウェアの「良さ」を表す様々な側面

* パフォーマンス(速い)
* 使いやすさ(分かりやすい)
* 保守性(変更しやすい)
* セキュリティ(安全)
* など

品質モデル: これらを体系的に整理したフレームワーク

## ISO 25010
ISO 25010 とは?
国際標準のソフトウェア品質モデル

* 2011年に初版公開(ISO 9126の後継)
* 2023年に改訂版公開
* ソフトウェア品質を評価・測定するための共通言語

2つのモデル:

* 利用時品質モデル: 実際に使った時の品質
* 製品品質モデル: ソフトウェア製品自体の品質




### 利用時の品質モデル
顧客満足の重要性

1. **有効性**: ユーザが目的を果たすための正確さと完全さ
1. **効率性**: ユーザが、望ましい正確さで完全に目的を果たすために消費されるリソース
1. **満足性**: 実用性、信頼性、快感性、快適性
1. **リスク回避性**: 経済、健康、安全、環境のリスク緩和性
1. **利用状況網羅性**: 利用状況完全性、柔軟性


### 製品品質モデル
機能要件と非機能要件をともに評価すること

1. **機能適合性**: 機能完全性、機能正確性、機能適切性
1. **性能効率性**: 時間効率性、資源効率性、容量満足性
1. **互換性**: 共存性、相互運用性
1. **ユーザビリティ**: 適切度認識性、習得性、運用操作性、ユーザエラー防止性、ユーザインタフェース快美性、アクセシビリティ
1. **信頼性**: 成熟性、可用性、障害許容性、回復性
1. **セキュリティ**: 機密性、インテグリティ、否認防止性、責任追跡性、真正性
1. **保守性**: モジュール性、再利用性、解析性、修正性、試験性
1. **移植性**: 適応性、設置性、置換性

# 設計のマインドセット
* 理解
  * 積極的に情報を集めて、問題を説明してもらうように働きかける
  * 要求を理解すること
  * 何が必要なのか
* 探求
  * 望み通りの品質特性を最もうまく促進させる組み合わせが見つかるまで、構造の組み合わせ・選択肢を試し続ける
  * 最適な組み合わせを見つけるには、パターン、技術、開発方法を調査しよう
* 作成
  * デザインされたコンセプトを形にすること
  * モデルを作成したり、プロトタイプ、ドキュメント、計算したりしてアーキテクチャを形をする
* 評価
  * 基準に従って設計判断が妥当かどうか判断する
  * すべてなし、すべてあり、だけではなく、一部を評価することもできる

これらを効果的には行うには**素早い**フィードバックループをもったプロセスが必要。


# 要求エンジニアリング
何が必要とされているか、正確に理解する前に作業を始めてしまう、ソフトウェア開発者はたくさん存在する。

「要求エンジニアリング」とは、要求の理解に貢献する、あらゆるタスクや技法のことである。

また、要求エンジニアリングは、プロセス、プロジェクト、製品、作業者のニーズを満たさなければならない。

要求エンジニアリングは、設計と構築を橋渡しする。

設計や構築のための強固な土台がなければ、開発したソフトウェアが、顧客のニーズを満たせない可能性は極めて高くなってしまう。

要求エンジニアリングのタスクは、反復的に実施するものであることを理解するのが重要である。

それは、プロジェクトチームとステークホルダそれぞれの懸念事項を共有し続けるためである。


ビジネスのニーズを定義し、ユーザシナリオや機能の概要を記述し、プロジェクトの制約を具体化する、といった具合である

要求エンジニアリングには、大きく分けて7つのタスクが含まれる。

- 方向付け(inception)
- 要求獲得(elicitation)
- 精緻化(elaboration)
- 交渉(negotiation)
- 仕様化(specification)
- 妥当性確認(validation)
- マネジメント(management)
- 
## 方向付け
>大半のプロジェクトは、特定のビジネスのニーズ、新たな市場、新たなサービスの可能性が発見されたときに始まるものである。プロジェクトの方向付け(inception)は、プロジェクトの課題や、解決方法を求める人々、望まれる解決方法の特性について、基本的な理解を得るために行う。ソフトウェア開発チームとすべてのステークホルダが、効果的にコラボレーションしていくには、方向付けによりコミュニケーションを確立しなければならない。

**方向付けの目的**

プロジェクトの方向付けでは、以下の3つについて基本的な理解を得ることを目指します:

* プロジェクトの課題 - 何を解決するのか
* 解決を求める人々 - 誰のための解決か
* 望まれる解決方法の特性 - どのような解決方法が求められているか

**方向付けの重要性**

ソフトウェア開発チームとすべてのステークホルダーが効果的に協力していくために、方向付けの段階でコミュニケーションを確立することが必要です。

つまり、プロジェクトの初期段階で関係者全員が共通認識を持ち、円滑な協力体制を築くことが重要ということです。

## 要求獲得
>要求獲得（elicitation） では、 ビジネス目標を明確  にすることが重要だと言われている［Cle10］。 

目標明確化の重要性
ビジネス目標とは、システムや製品が達成すべき長期的な目標のことです。これには以下が含まれます:
* 機能的側面(何ができるか)
* 非機能的側面(信頼性、セキュリティ、使いやすさなど)

**目標を明確にする理由**

目標を明確にすることで、以下のような様々な活動の土台となります:

* ステークホルダへの要求説明
* 関係者間の利害調整
* 要求の精緻化、検証、妥当性確認
* 競合管理、交渉、説明
* システムの進化への対応

**ソフトウェアエンジニアの役割**

* ステークホルダがビジネス目標に関心を持つよう促す
* 全員で目標を共有できるよう支援する
* 目標明確化後、優先順位付けの仕組みを確立する
* その仕組みが将来的にステークホルダの目標を実現できることを裏付ける

**アジリティ(機敏性)の重要性**

要求獲得では、ステークホルダの考えを迅速かつスムーズに開発チームへ伝えることが目的です。
特に反復的な開発では、新しい要求が継続的に生まれるため、柔軟な対応が不可欠です。

# 設計
要求の分析と要求に対するモデリングが完了したらコーディングやテストの前にやるべきアクションが存在する。

4種の設計モデル
* コンポーネント設計
  * アーキテクチャの構成要素を関係性とともに示す
* インタフェース設計
  * 情報(データや制御、処理など)の流れや具体的な振る舞いを定義
  * 利用シナリオや振る舞いのモデルから定義されることが大半
* アーキテクチャ設計
  * ソフウェアの主要な構成要素の関係を定義
  * システムが要求を満たすために利用するパターン、実現手法の制約を定義
* データ設計・クラス設計
  * CRCモデルで定義したオブジェクトやその関係性および属性をもとに具体的な設計クラスに変換


設計時に行う決定は、最終的にソフトウェアの構築が成功するかどうかに影響する。 
また、同じくらい重要なのが、容易に保守できるソフトウェアになるかどうかにも影響する点である。 


# モデルで複雑さを扱う
コードを書く前に構造を整理しよう
- どんな要素(クラス、モジュール)が必要?
- それらはどう繋がる?
- より良い名前は？
- 要求や求められている概念は何かを漏れなく明確に
  - 5W1Hを使おう
  - 制約を必ず聞く・考える
  - 「なぜ」を聞く


# パターンの土台を身につける
* レイヤーパターン
  * ある関心事のまとまりに沿って整理された、個別の独立したレイヤー群にコードを分割
  * すべてのモジュールは1つのレイヤーにのみ割り当てられている
  * 上位レイヤーは下位レイヤーを使用することができるかが、この関係は一方通行。循環依存はなし
  * 保守性、移植性、再利用性、テスト容易性、修正変更性を促進
  * レイヤーが多すぎるか、抽象が漏れすぎると、開発者が困難
* ポートとアダプター
  * 核となるビジネスロジックを分離する
  * よくあるのが外部システム(バックエンドAPI、ストレージ)の実装を分離
* パイプとフィルター
* サービス志向アーキテクチャ
* 共有データ
* イベント駆動
  * パブリッシュ・サブスクライバー
  * イベントストリーミング
  * イベントソーシング
  * メッセージキュー

# データ設計

# インタフェース設計
インタフェース設計は、システムへ入出力する情報の流れや、アーキテクチャを構成するコンポーネント同士がどのように情報をやりとりするのか表現する。 

インタフェース設計の3種類の要素
* UI
* 外部インタフェース
* 内部インタフェース

## 外部インタフェース
システムに対して情報を送受信するエンティティ(データの種類、値、意味など)の正確な情報を集めることが必要。

要求、やりたいことに対して必要な情報に対して、過不足ないか矛盾がないかなど検証が必要。

検証は情報が得られた時に行うこと。

## 内部インタフェース
コンポーネント、クラス、関数（フック）同士のやりとりや協調動作に必要な操作がもれなく表現すること。

操作に求められる機能要件を満たすこと。


# 設計判断を可視化する

アイデアを共有すること。

抽象的なアイデアについて話す必要がある場合は、スケッチを始めること。

図はきれいである必要はない。

設計をタンジブルにする（＝設計を目に見える形で整理し、誰でもわかりやすく共有できるようにする）アクティビティ
* 要素責務ビュー
* アーキテクチャデシジョンレコード
* コンテキスト図
* 品質特性ビュー
* シーケンス図
* 状態遷移図
* データフロー図
* etc




# 潜在的な解決策を探る
* CRCカード
  * 目的  
    * 会話のツール
    * 責務と依存の明確化
  * 流れ
    * クラス、モジュール、コンポーネントを洗い出す
    * 責務を割り当てる
    * 協力関係を考える
    * シナリオを試す
      * カードを並べて、頭の中でシナリオを追う
      * 「このクラスは次にどうする?」と自問自答or議論
    * 改善

# 比較評価マトリクス

複数のアーキテクチャ案を品質特性や制約条件に基づいて客観的に比較し、最適な設計を選択するために使う。
アーキテクチャ設計では「完璧な解」はなく、制約の中で最もバランスの取れた選択をするためのツール。

形式
* ○△×形式（定性評価）
* 重み付けスコア
* トレードオフマトリクス(Gain/Pain)
* 要件充足度マトリクス
* リスク評価

# アーキテクチャデシジョンレコード(ADR)
軽量なテンプレートを使ってアーキテクチャ上の設計判断を記録する。
設計判断を記録することで、共有や分析が容易。
過去の過程をもとに現在の設計判断ができる、また未来の展望を得られる。

## 記述
重要なアーキテクチャ上の設計判断とその判断の背景および影響を書き留める。
各ADRには一つの設計判断を記述する。

## テンプレート

```
# [タイトル]

## ステータス
[提案中 | 承認済み | 却下 | 廃止 | 置き換え]

## 日付
YYYY-MM-DD

## 背景・課題
何が問題だったのか? なぜ判断が必要になったのか?

## 判断
何を決めたのか?

## 選択肢
どんな選択肢を検討したか?

### 選択肢1: [名前]
- 概要:
- メリット:
- デメリット:

### 選択肢2: [名前]
- 概要:
- メリット:
- デメリット:

### 選択肢3: [名前]
- 概要:
- メリット:
- デメリット:

## 判断の理由
なぜこの選択肢を選 んだのか?

## 影響・結果
この判断によって何が変わるのか?

## 関連するADR
- ADR-xxx: [関連するADRがあれば]
```
---

# SOLID原則
1. SRP: 単一責任の原則
1. OCP: 開放閉鎖の原則
1. LSP: リスコフの置換原則
1. ISP: インタフェース分離の原則
1. DIP: 依存性逆転の原則

## SRP (Single Responsibility Principle)

> モジュールを変更する理由はたったひとつだけであるべきである。

## OCP (Open Closed Principle)

コンポーネントや関数の拡張に対しては開いて、変更に対しては閉じているべき。

## LSP (Liskov Substitution Principle)
基底クラス(親)を使っているところで、派生クラス(子)に置き換えても、正しく動作すべき。

## ISP (Interface Segregation Principle)
クライアントは、使わないインターフェースに依存を強制されるべきではない。

## DIP (Dependency Inversion Principle)
具象ではなく、抽象に依存せよ。
高レベルモジュールは低レベルモジュールに依存してはならない。両方とも抽象に依存すべき。

# 引用・参考
* Design It! ―プログラマーのためのアーキテクティング入門
  * Michael Keeling　著、島田 浩二　訳
  * https://www.oreilly.co.jp//books/9784873118956/
* ソフトウェアアーキテクチャの基礎 ―エンジニアリングに基づく体系的アプローチ
  * Mark Richards、Neal Ford　著、島田 浩二　訳
  * https://www.oreilly.co.jp//books/9784873119823/
* Clean Architecture 達人に学ぶソフトウェアの構造と設計
  * Robert C. Martin(著), 角征典, 髙木正弘(訳)
  * https://asciidwango.jp/post/176293765750/clean-architecture
* 実践ソフトウェアエンジニアリング（第9版）
  * Roger S. Pressman 著、Bruce R. Maxim 著、SEPA翻訳プロジェクト 訳
  * https://www.ohmsha.co.jp/book/9784274227943/
